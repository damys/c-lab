#include <stdio.h>
#include "num.h"   //函数的声明

//多模块开发，要声明一下
int sum(int num1, int num2);   //使用.h文件，可直接使用

int main(int argc, const char * argv[]) {
    
    //使用sum 模块
   printf("%d\n",sum(2,3));
    
    
    //利用位高效判断数字是偶数还是奇数
   int num = 10;
   if((num & 1) == 0)
       printf("偶数\n");
   else
       printf("奇数\n");
    
    

    
    //进制
    /*
     数码：指的是每位的数字
     数位：数码在这个数中的位置，从右到左，依次递增，从0开始
     基数：就是每个数码可以有多少个数据来表示，基数就是这个数的进制数，如2，8，10，16
     位权：数码 乘以 基数的数次方，0次方为1
     如：12345中的3。数码：3，数位：2，基数：10进数，位权：10的2次方
     
     10转2：除2取余。直到商为1或0，倒过来便是。如10：1010
     2转10：加权法，数码权位相加。如：10101
         1 * 2的0 = 1
         0 * 2的1 = 0
         1 * 2的2 = 4
         0 * 2的3 = 0
         1 * 2的4 = 16
             加起来=21
         规则：1，2，4，8，16，32，64，128，256，...
     
     10转8：除8取余，这个数除8，直到小于8
     8转10：加权法。如：0342:226
     
     2转8：三合一法则，将这个二制从低到高位每三位分成一组，高位不句补0，将每1组转为10进制，将每1组的10进制制起来就是
     001 011 100 110 011
       1 1+2 4   4+2  2+1 = 13463
       
     8转2：一拆三，将这个8制数的每个数码拆为一个三位的二进制数，把这些2进制连起来
       1  3  4   6    3
     001 011 100 110 011
     
     2转16：四合一法则。将这个二进制从低位到高位每四位分成一组，高位不够补0，将每1组转换为对应的16进制，将每1组转换成功的16进制连接起来
      0001 1100 1010 1011 1110 1111 0101 0101
         1 c    a    b    e    f     5   5    = 1cabef55
         
     16转2：一拆法则。将这个16进制的数的每1个数码拆为1个四位的二进制，将其连接来
         1 c    a    b    e    f     5   5
      0001 1100 1010 1011 1110 1111 0101 0101 = 11100101010111110111101010101
     
     8转16顺序：8->2->16
     
     */
    
    
       int num1 = 0123;   //2进制--10:83 16:123
       int num2 = 0b10100; //8进制--10:20 16:24
       int num3 = 0b00011100101010111110111101010101; //2转16：1cabef55
       printf("%d\n", num1);
       printf("%o\n", num2);
       printf("%x\n", num3);
    
    /*
     科学家为了更方便存储数据，他们就把内存中的8个二进制位，分为1组，叫做1个字节，作为存储数据的最小基本单位
     如果你要往内存中存储数据的话，就至少要使用1个字节，也就是8个二进制位
     1个字节就可以表示256种数据：2的8次方
     
     内存的存储单元是由1个1个的二制位组成的，每1个二进制位只能存储1或0
     8bit = 1字节 byte
     1024字节 =  1K
     1024k  = 1MB
     8G 占的字节数：8 * 1024 * 1024 * 1024 [如：位数加乘以 * 8]
     
     声明变量的时候，并不是去开辟1块空间，而是向系统在内存中申请1个指定字节数的连续字节空间
     int 4字节
     double 8字节， 如果一个数字如：12.22f字节数为4， 不加f为8个字节数
     float  4字节
     char   1字节  注：char的常量占4个字节
     
     */
    
    //sizeof(变量名[,常量 ,数据类型]) 运算符，计算变量，常量在内存中占用的字节数
    //简写：siezeof num1;  //数据类型要加小括弧
   printf("%d\n", sizeof(int));   //4
   printf("%d\n", sizeof(char));   //1
    
   int num1 =  3 & 2;   //2
   int num2 =  -3 & -4; //-4
   int num3 = 3 | 2;    //3
   int num4 = ~3;       //-4
   int num5 = 3 ^ 2;    //1
   int num6 = 3 << 2;   //12   3*4
   int num7 = 16 >> 2;  //4    16/4
   printf("%d\n", num7);
    
    //取地址，对比地址
   int num1 = 10;
   int num2 = 20;
   int result1 = &num1 - &num2;   //1
   int result2 = &num2 - &num1;   //-1
   printf("数据的地址:%p\n", &num1); //0x7fff5fbff7cc
   printf("数据的地址:%p\n", &num2); //0x7fff5fbff7c8
   printf("%d\n", result2);
    
    //int 大小，修饰符，占位符
   int num = 10;          //4个字节
   short int num1 = 10;    //2个字节，int 可省掉, 占位符：%hd
   long int num2 = 10;     //8个字符，int 可省掉, 占位符：%ld
   long long int num3 = 10;//在32，64位系统都占8个字符，int 可省掉，占位符：%lld
   
   int len1 = sizeof(num1); //2  占位符：%d, %lu
   int len2 = sizeof(num2); //8
   
   printf("%ld\n", num2);
    
    //unsigned 修饰符， 最高位不要表示符号位，这样就有32位来表示数据，最大值就翻了1位，最小值是0
   unsigned int num1 = 2300000000;     //原超过21亿就不能正常输出, 占位符：%u
   unsigned short num2 = 10;           //占位符：%hu
   unsigned long num3 = 10;            //占位符：%lu
   unsigned long long num4 = 10;       //占位符：%llu
   
   printf("%llu\n", num4);
    
    //signed 就是默认的符号位    
    //char 是有符号，在内存中存储是这个字符的ASCII码的二进制补码。
    //如 char ch = 'a' ==>97
    char ch1 = 97;
    printf("%c\n", ch1);  //a
    printf("%d\n", ch1);  //97, 也可以使用占位符：%d
    
    unsigned char ch2 = 255;
    printf("%c\n", ch2);  //\377
    printf("%d\n", ch2);  //255
    

    
    return 0;
}
