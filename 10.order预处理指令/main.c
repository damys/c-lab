/*

预处理指令的特点：
    1. 预处理都是在编译，检查语法之前执行
    2. 都是以#开头，都没有分号
预处理指令的分类：
    1. 文件包指令：#include
    2. 宏定义：可以将1段C代码定义为1个标识，使用这个标识可以使用这段代码
    3. 条件编译指令：只编译指定的C代码为二进制指令
 
 
C程序从编写到编译，链接，执行的一个流程
   1）创建一个.c的源文件
   2）在.c 源文件里写上符合C语法规范的源代码。注：源代码区分大小写，
   3）编译文件：cc -c 源文件名
        a. 先执行源文件中的预处理指令。就是把预处理指令源copy 进来
        b. 检查源文件中的语法是否符合规范，符合就生成.o文件，就是.c文件对应的二进制指令
   4）链接： cc xx.o。 
        a. 为.o的文件添加启动代码
        b. 链接函数：告诉编译器要调用的函数在什么位子
        c. 调用的时候，去正确的位子找，链接成功后就会生成一个可执行的文件：xx.out
   5）生成:xx.out 可执行文件。其文件’包含’所有用到库的所有文件。
 
 */
#include <stdio.h>
#define N1 10
#define N2 10 + 10
#define N3 20
#undef N3     //N3实效
/*
 1. 无参数的宏 define, undef
     作用: 可以将1段代码定义为1个标识,然后使用这个标识
     原理: 在预编译的时候,会将写宏名的地方替换为宏值
     注意: 
         1. 在定义的时候,是不会检查语法
         2. 无法通过赋值符号为宏赋值,改值,因为宏根本就不是变量
         3. 如果宏值中包括1个变量,那么在使用这个宏之前必须要保证这个变量已经存在
         4. 如果宏址是1个表达式,那么宏值并不是这个表达式的结果,而是这个表达式本身
         5. 宏的作用域:可以定义在函数内部或外部, 从定义宏的地方,都可以使用(编译原理:由上至下)
         6. 双引号引起来的宏会认为是一个字符串,原样输出
         7. 宏值后加分号,宏值替换的时候会将分号作为赋值的一部分   #define NUM 10;
         8. 可以将任意的代码定义为宏
            #define P printf
            #define D "%d\n"
            使用:P(D, num1);
 
         9. 宏的层层替换
             #define PI 3.14
             #define R 3
             #define AREA PI * R * R   // 3.14 * 3 * 3
 
     区别: define 与 typeof(是一个C代码,在运行时才会执行,只为数据类型取名子)
 */



#define M(a) a + a
#define SUM(a, b) a + b
#define MAX(a, b) a > b ? a : b
/*
  2. 有参数的宏
     先将传入的值传递给宏的参数,再把宏值当中使用的地方换成参数的值,最后替换为最后的值
     注意:
         1. 宏的参数不需要加类型说明符  SUM(int a, int b) a + b
         2. 宏名:#define 空格 宏名 空格 宏值   #define  E F 30 宏名:E
         3. 宏一换行就结束了,所有替换函数就困难了
         4. 为宏传参是本色传值
           SUM(a, b) a + b
           int num1 = 2;
           int num2 = 3;
           SUM(num1, num2);    //num1 + num2  不会把他们的值传给它, 即不会变为: 2 + 3
 
 
 
 
 */

#define N 5

int main(int argc, const char * argv[]) {
    //无参数宏
   int num1 = N1 * 2;
   int num2 = N2 * 2;
   printf("num:%d\n", num1);   //20 = 10 * 2
   printf("num:%d\n", num2);   //30 = 10 + 10
    
#define P printf
#define D "%d\n"
   P(D, num1);   == printf("%d\n", num1)
    
    //有参数宏
   int num1 = M(2);
   printf("%d\n", num1);  //4 = 2 + 2
   
   int sum = SUM(2, 3);
   printf("%d\n", sum);  //5 = 2 + 5
   
   int max = MAX(4, 6);  //6
   printf("%d\n", max);
    
    
/*
     条件编译指令
         条件编译指令: 这是1个预处理指令,所有在预编译阶段执行
         作用: 默认的情况下,我们所有的C代码都会被编译为二进制代码,
         条件编译指令失作用:可以让编译器只编译指定部分的代码
        
        用法:
        #if 条件
          C代码
       #endif
       在编译的时候,如果条件成立,就会将其中的C代码编译成二进制指令,
                     条件不成立,就不会编译
      注意:条件只能是宏,因为编译还没有变量
 */
    
#if N == 5     //不能写变量
   printf("被执行\n");    //此行会被输出
#endif
   printf("不被执行\n");
   
   //扩展1  会输出:大于0, 后面不会被编译, 而if,else if 都要编译. 即二都不能替换
#if N > 0
   printf("大于0\n");
#elif N > 3
   printf("大于3\n");
#elif N > 10
   printf("大于10\n");
#endif
    
    //扩展2: 判断定义了宏, 会输出:在宏定义了
#ifdef N
   printf("宏定义了\n");
#endif
   
   //扩展3: 判断没有定义宏, 会输出: 不会输出
#ifndef N
   printf("宏没有定义\n");
#endif
   
   //扩展4: 不会被包含多次
#ifndef N
#define N 10
#include <stdio.h>
   //这里可以写代码
#endif
    
    
/*
 static，extern 修饰变量和函数
     1. 修饰局部变量：static 变是静态变量，不存在栈区，而存在常量区，直到程序执行完才被加收
     extern 不能修饰局部变量
     
     2. 修饰全局变量：一般先声明，再初始化/实现: 一般在要用的函数体前外面：int num; num = 10; 如只有声明没有实现，系统会自动初始化为0
     当用模块开发时，声明就要用static 或 extern 修饰。
     extern修饰 就可以跨模块访问，反之static 就不行
     
     3. 修饰函数：extern修饰 可以跨模块调用，反之static 就不行
     如果函数没有写extern/static, 那么默认就是：extern
     
     写一个函数的完整步骤：先声明，后实现
 */
    
    
    /*
     
     总结数据类型
     1. 基本数据类型:int, double, float, char
     2. 构造类型: 数组, 结构体, 枚举
     3. 指针
     4. void 空类型
     5. tyofdef 定义类型 typedef int schoole;
     
     
     
     
     
     
     */
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    return 0;
}
